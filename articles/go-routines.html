<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深度解析 Go 协程与通道 - 我的技术博客</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="three-canvas"></canvas>
    <div id="particles-js"></div>
    <header>
        <div class="container">
            <h1>我的技术博客</h1>
            <p>分享关于 Java, Go, 云原生等技术的文章</p>
        </div>
    </header>
    <main class="container">
        <article class="post-full">
            <h1>深度解析 Go 协程与通道</h1>
            <p class="post-meta">发布于 <time datetime="2024-07-29">2024年7月29日</time> | Go</p>
            <div class="post-content">
                <p>Go 语言的并发能力是其最吸引人的特性之一。它并非简单地将操作系统的线程暴露给用户，而是构建了一套更高层次、更轻量级的并发模型。本文将深入探讨 Goroutine 的调度原理 G-P-M 模型，以及 Channel 的一些高级应用模式。</p>
                
                <h2>G-P-M 调度模型</h2>
                <p>Go 的调度器核心是 G-P-M 模型，它负责将大量的 Goroutine 高效地调度到少量的系统线程上执行。</p>
                <ul>
                    <li><strong>G (Goroutine)</strong>: 即我们代码中的 `go` 关键字创建的执行单元。它包含了指令指针和栈，是轻量级的，初始栈大小仅为 2KB。</li>
                    <li><strong>P (Processor)</strong>: 表示一个逻辑处理器。P 维护了一个本地的 Goroutine 队列（LRQ），调度器会将 G 分配给 P。P 的数量默认等于 CPU 核心数。</li>
                    <li><strong>M (Machine)</strong>: 代表一个操作系统线程。M 是真正执行计算资源的实体。一个 M 必须绑定一个 P 才能执行 G。</li>
                </ul>
                <p>当一个 G 被创建时，它会被放入 P 的本地队列。M 从 P 的队列中取出 G 并执行。如果 P 的队列为空，它会从全局队列或其他 P 的队列中"窃取"G 来执行，这种 work-stealing 机制确保了所有 M 都能保持忙碌，最大化 CPU 利用率。</p>

                <h2>高级 Channel 模式</h2>
                <p>Channel 不仅仅是数据管道，通过 `select` 关键字，我们可以构建出复杂的并发模式。</p>
                <h3>Fan-Out / Fan-In</h3>
                <p>这是一种常见的并行处理模式。一个生产者将任务分发到多个 worker Goroutine（Fan-Out），这些 worker 并行处理任务，然后将结果汇总到一个 Channel 中（Fan-In）。</p>
                <pre><code>
func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        // processing job...
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)

    // Fan-Out: 3 workers
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    // Send 5 jobs
    for j := 1; j <= 5; j++ {
        jobs <- j
    }
    close(jobs)

    // Fan-In: Collect results
    for a := 1; a <= 5; a++ {
        <-results
    }
}
                </code></pre>
                
                <h3>带超时的 `select`</h3>
                <p>在进行阻塞操作（如网络请求或 Channel 通信）时，设置超时非常重要，可以防止 Goroutine 无限期地阻塞。</p>
                <pre><code>
select {
case res := <-c:
    fmt.Println(res)
case <-time.After(1 * time.Second):
    fmt.Println("timeout 1")
}
                </code></pre>
                <p>`time.After` 会在指定时间后向其返回的 Channel 发送一个值，从而触发超时分支。</p>

                <h2>总结</h2>
                <p>通过 G-P-M 模型，Go 调度器实现了 M:N 的线程模型，以极低的成本实现了高并发。而 Channel 和 `select` 的结合则提供了强大而安全的工具来编排 Goroutine。深刻理解这些底层机制和高级模式，是编写出健壮、高效的 Go 并发程序的关键所在。</p>
            </div>
        </article>
        <a href="../index.html" class="back-to-home">&larr; 返回首页</a>
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2024 我的技术博客. All Rights Reserved.</p>
        </div>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="../particles.js"></script>
    <script src="../app.js"></script>
    <script src="../3d-animation.js"></script>
</body>
</html> 