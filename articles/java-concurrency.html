<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深入 Java 并发：从 JMM 到 AQS - 我的技术博客</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="container">
            <h1>我的技术博客</h1>
            <p>分享关于 Java, Go, 云原生等技术的文章</p>
        </div>
    </header>
    <main class="container">
        <article class="post-full">
            <h1>深入 Java 并发：从 JMM 到 AQS</h1>
            <p class="post-meta">发布于 <time datetime="2024-07-28">2024年7月28日</time> | Java</p>
            <div class="post-content">
                <p>Java 的并发能力构建在一套复杂而精密的模型之上。要真正掌握 Java 并发，仅仅了解 `Thread` 和 `synchronized` 是远远不够的。本文将深入探讨 Java 内存模型 (JMM)、`volatile` 的工作原理，并最终揭开 `java.util.concurrent` 包的基石——`AbstractQueuedSynchronizer` (AQS) 的神秘面纱。</p>
                
                <h2>Java 内存模型 (JMM)</h2>
                <p>JMM 是一种抽象规范，它定义了线程和主内存之间的交互方式。它规定了所有的变量都存储在主内存（Main Memory）中，而每个线程都有自己的工作内存（Working Memory）。线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存。</p>
                <p>JMM 的核心目标是解决并发编程中的三个问题：</p>
                <ul>
                    <li><strong>原子性 (Atomicity)</strong>: 一个或多个操作，要么全部执行且执行的过程不会被任何因素打断，要么就都不执行。</li>
                    <li><strong>可见性 (Visibility)</strong>: 当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</li>
                    <li><strong>有序性 (Ordering)</strong>: 程序执行的顺序按照代码的先后顺序执行。在多线程环境中，编译器和处理器可能会对指令进行重排序。</li>
                </ul>

                <h2>`volatile` 的深度解析</h2>
                <p>`volatile` 是 Java 提供的轻量级同步机制。它能保证两件事：可见性和一定程度的有序性（禁止指令重排序）。</p>
                <p>当一个变量被声明为 `volatile` 后，对它的写操作会强制将修改后的值立即刷新到主内存，同时使其他线程本地缓存的该变量失效。读操作则会强制从主内存重新加载变量值。这背后通常是通过处理器的"内存屏障"（Memory Barrier）指令来实现的。</p>
                
                <h2>并发之基：AbstractQueuedSynchronizer (AQS)</h2>
                <p>AQS 是 `java.util.concurrent` 包下几乎所有锁和同步器的核心框架，包括 `ReentrantLock`, `Semaphore`, `CountDownLatch` 等。</p>
                <p>它巧妙地将两部分功能结合起来：</p>
                <ol>
                    <li><strong>状态 (State)</strong>: 一个 `int` 类型的变量，表示同步状态。子类通过 `getState`, `setState`, `compareAndSetState` 来管理它。例如，在 `ReentrantLock` 中，state 表示锁的持有次数。</li>
                    <li><strong>一个 FIFO 的等待队列</strong>: 一个由 Node 组成的双向链表，用于管理所有等待获取同步状态的线程。当一个线程尝试获取锁失败后，它会被封装成一个 Node 加入到队列的尾部并被挂起。当锁被释放时，头部的 Node 会被唤醒，尝试获取锁。</li>
                </ol>
                <p>AQS 的设计是一种典型的模板方法模式。它将通用的队列管理、线程阻塞/唤醒等逻辑封装好，而将具体的状态获取/释放逻辑（`tryAcquire`, `tryRelease` 等）交由子类去实现。这种设计极大地简化了并发工具的开发。</p>
                <pre><code>
// Simplified ReentrantLock logic using AQS
public class MyLock implements Lock {
    private static class Sync extends AbstractQueuedSynchronizer {
        protected boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            // ... reentrant logic
            return false;
        }

        protected boolean tryRelease(int releases) {
            // ... release logic
        }
    }
    // ...
}
                </code></pre>
                <h2>总结</h2>
                <p>从 JMM 的抽象规范，到 `volatile` 对可见性和有序性的保障，再到 AQS 提供的强大并发框架，Java 的并发体系层层递进、设计精良。理解这些底层原理，是成为一名优秀的 Java 并发程序员的必经之路。</p>
            </div>
        </article>
        <a href="../index.html" class="back-to-home">&larr; 返回首页</a>
    </main>
    <footer>
        <div class="container">
            <p>&copy; 2024 我的技术博客. All Rights Reserved.</p>
        </div>
    </footer>
</body>
</html> 